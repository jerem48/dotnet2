
Tasks for Today

1.First Create a new Blank solution EntityDemoSolution.
2.Add new Empty asp.net Web Application Project EntOnlineWeb with MVC folder Structure.
3.Add App_Data folder in EntOnlineWeb project.
4.Copy ECommerece database in App_Data folder of EntOnlineWeb project.
5.Add connectionstring to Web.config file of EntOnlineWeb project.
6.Add a new Entity ADO.NET Model in EntOnlineWeb Project.
7.Choose your Database to build Entities using Entity Framework Wizard.
8.Rebuild whole solution to generate EntityFramework classes in DBContext.
8.Add ProductController, CategoryController, CustomerController, Paymentcontorller with the help of Models from Entity Framework.
8.Add all methods, Views for all controllers.
9.Build and Run Application to test all controller working with all action methods.
10. Modify layout.cstml file to provide links for all controller above in Default Navigations.
11.Explore lines of code generated by wizard of visual studio.net.
12.Add Empty asp.net Web Application Project FilterDemoOnlineWeb with MVC folder Structure.
13.Add Home Controller with Action methods Index and OutputTest.
14.Write [OutputCache(Duration=10)] to OutputTest Action  method of HomeController.
15.Add CustomActionFilterAttribut to dump logging information in ViewBag by overriding pre and post Events of Filter.
16.User CustomActionFilter as [CustomActionFilter] to action method Index of HomeController in FilterDemoOnlineWeb Web Project.
17.Run application with Default index as action method by modifying code in App_Start folder.
18.Understand and Memorise following internals of asp.net Application Execution cyclt and it's Filter Pipeline.
20.Explore the diagram which explains how Request is executed in asp.net MVC shared with you in Day18 folder.
..........................................................................................................................................................

Routing

Routing is the first step in ASP.NET MVC pipeline. 

it is a pattern matching system 
		
		that matches the incoming request to 
			
		the registered URL patterns in the Route Table.


When ASP.NET MVC application starts at first time, 
	it registers one or more patterns to the RouteTable to tell the routing system what to do with any requests that match these patterns. 

An application has only one RouteTable and this is setup in the Application_Start event of Global.asax of the application.



public class RouteConfig
 {
 public static void RegisterRoutes(RouteCollection routes)
 	{
 		routes.IgnoreRoute("{resource}.axd/{*pathInfo}");
 
 		routes.MapRoute(
 			name: "Default",
 			url: "{controller}/{action}/{id}",
 			defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
 			);
 	}
 }



protected void Application_Start()
{
	 //Other code is removed for clarity
	 RouteConfig.RegisterRoutes(RouteTable.Routes);
}







When the UrlRoutingModule finds a matching route within RouteCollection (RouteTable.Routes), 
	it retrieves the IRouteHandler(System.Web.Mvc.IRouteHandler) instance(default is System.Web.MvcRouteHandler) for that route. 

	From the route handler, the module gets an IHttpHandler(System.Web.IHttpHandler) instance(default is System.Web.MvcHandler).

	public interface IRouteHandler
	{
		 IHttpHandler GetHttpHandler(RequestContext requestContext);
	}


Controller Initialization


The MvcHandler initiates the real processing inside ASP.NET MVC pipeline by using ProcessRequest method. 


This method uses the IControllerFactory instance (default is System.Web.Mvc.DefaultControllerFactory) to create corresponding controller.


	protected internal virtual void ProcessRequest(HttpContextBase httpContext)
	{
 		SecurityUtil.ProcessInApplicationTrust(
		     delegate 
		     {
 			IController controller;
 			IControllerFactory factory;
 			
			this.ProcessRequestInit(httpContext, out controller, out factory);
 			
			try
 			{
				 controller.Execute(this.RequestContext);
 			}
 			finally
 			{
 				factory.ReleaseController(controller);
 			}
 		     });
}




Action Execution

1.When the controller is initialized, the controller calls its own InvokeAction() method by passing the details of the chosen action method. 
  This is handled by the IActionInvoker.

  public virtual bool InvokeAction(ControllerContext controllerContext, string actionName)




2.After chosen of appropriate action method, model binders(default is System.Web.Mvc.DefaultModelBinder) retrieves the data from incoming HTTP request 
	and do the data type conversion, 
		   data validation such as required or date format etc. 
                   and also take care of input values mapping to that action method parameters.



3.Authentication Filter was introduced with ASP.NET MVC5 that run prior to authorization filter. It is used to authenticate a user. 
  Authentication filter process user credentials in the request and provide a corresponding principal. 
  Prior to ASP.NET MVC5, you use authorization filter for authentication and authorization to a user.
	By default, Authenticate attribute is used to perform Authentication. 
	You can easily create your own custom authentication filter by implementing IAuthenticationFilter.



4.Authorization filter allow you to perform authorization process for an authenticated user. 
	For example, Role based authorization for users to access resources.
	By default, Authorize attribute is used to perform authorization. 
	You can also make your own custom authorization filter by implementing IAuthorizationFilter.



5.Action filters are executed before(OnActionExecuting) and after(OnActionExecuted) an action is executed. 

	IActionFilter interface provides you two methods 

		OnActionExecuting 
		and OnActionExecuted methods 

			which will be executed before and after an action gets executed respectively. 

	You can also make your own custom ActionFilters filter by implementing IActionFilter.



6.When action is executed, it process the user inputs with the help of model (Business Model or Data Model) and prepare Action Result.





ASP.NET Filters


ASP.NET MVC provides a simple way to inject your piece of code or logic either before or after an action is executed. 


This is achieved by decorating the controllers or actions with ASP.NET MVC attributes or custom attributes. 


An attribute or custom attribute implements the ASP.NET MVC filters(filter interface) and can contain your piece of code or logic. 


You can make your own custom filters or attributes either by implementing ASP.NET MVC filter interface 
     or by inheriting and overriding methods of ASP.NET MVC filter attribute class if available.


Typically, Filters are used to perform the following common functionalities in your ASP.NET MVC application.

1.Custom Authentication
2.Custom Authorization(User based or Role based)
3.Error handling or logging
4.User Activity Logging
5.Data Caching
6.Data Compression





The ASP.NET MVC framework provides five types of filters.


	Authentication filters (New in ASP.NET MVC5)
	Authorization filters
	Action filters
		
	Result filters
	Exception filters




	Authorization filters




	Action filters
		Action filters are executed before or after an action is executed. The IActionFilter interface is used to create an Action 



	Result filters
		Result filters are executed before or after generating the result for an action. 
		The Action Result type can be ViewResult, PartialViewResult, 
					      RedirectToRouteResult, RedirectResult, 
					      ContentResult, JsonResult, FileResult 
                                              and EmptyResult which derives from the ActionResult class. 



	Exception filters
		Exception filters are executed when exception occurs during the actions execution or filters execution.

	



All ASP.NET MVC filter are executed in an order. The correct order of execution is given below:
	1.Authentication filters
	2.Authorization filters
	3.Action filters
	4.Result filters







[Authorize(Roles="Admin")]
public class AdminController : Controller

{
		 //
}




public class UserController : Controller

{

 [Authorize(Users="User1,User2")]

 public ActionResult LinkLogin(string provider)
 {
	 // TODO:
 	 return View();
 }


}





Result Execution

Result filters are executed before(OnResultnExecuting) and after(OnResultExecuted) the ActionResult is executed. 



IResultFilter interface provides you two methods 

	OnResultExecuting 
	and OnResultExecuted methods 
		which will be executed before and after an ActionResult gets executed respectively. 



You can also make your own custom ResultFilters filter by implementing IResultFilter.

Action Result is prepared by performing operations on user inputs with the help of BAL or DAL. 




The Action Result type can be 


	ViewResult, PartialViewResult, 
	RedirectToRouteResult, RedirectResult, 
	ContentResult, JsonResult, 
	FileResult and EmptyResult.



Various Result type provided by the ASP.NET MVC can be categorized 


	into two category- 

		ViewResult type and NonViewResult type. 

	The Result type which renders and returns an HTML page to the browser, falls into ViewResult category 
	
	and other result type which returns only data either in 
			text format, 
			binary format 
			or a JSON format, 
		falls into NonViewResult category.


View Initialization and Rendering

	ViewResult type i.e. view and partial view are represented by IView(System.Web.Mvc.IView) interface 
		and rendered by the appropriate View Engine.


	public interface IView
	{
 		void Render(ViewContext viewContext, TextWriter writer);
	}



	This process is handled by IViewEngine(System.Web.Mvc.IViewEngine) interface of the view engine. 

	By default ASP.NET MVC provides 
			WebForm 
			and Razor view engines. 


	You can also create your custom engine by using 
			IViewEngine interface 
			and can registered your custom view engine in to your Asp.Net MVC application as shown below:



	protected void Application_Start() 
	{ 
 		//Remove All View Engine including Webform and Razor
 		ViewEngines.Engines.Clear();
 		
		//Register Your Custom View Engine
 		ViewEngines.Engines.Add(new CustomViewEngine());
 		//Other code is removed for clarity
	} 




Html Helpers are used 

	to write input fields, 
	   create links based on the routes, AJAX-enabled forms, links and much more. 


Html Helpers are extension methods of the HtmlHelper class 
	and can be further extended very easily. 

	In more complex scenario, it might render a form with client side validation with the help of JavaScript or jQuery.














